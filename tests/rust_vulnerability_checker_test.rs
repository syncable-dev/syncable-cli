#[cfg(test)]
mod tests {
    use serde_json::Value;
    use syncable_cli::analyzer::dependency_parser::{DependencyInfo, Language, DependencyType};
    use syncable_cli::analyzer::vulnerability::checkers::rust::RustVulnerabilityChecker;
    use syncable_cli::analyzer::vulnerability::{VulnerabilitySeverity};

    #[test]
    fn test_parse_cargo_audit_output_with_warnings() {
        // Read the test cargo audit output
        let test_data = include_str!("../test_cargo_audit_output.json");
        let audit_data: Value = serde_json::from_str(test_data).expect("Failed to parse test data");
        
        let checker = RustVulnerabilityChecker::new();
        let dependencies = vec![
            DependencyInfo {
                name: "gix-features".to_string(),
                version: "0.38.2".to_string(),
                dep_type: DependencyType::Production,
                license: "MIT".to_string(),
                source: Some("crates.io".to_string()),
                language: Language::Rust,
            },
            DependencyInfo {
                name: "term_size".to_string(),
                version: "0.3.2".to_string(),
                dep_type: DependencyType::Production,
                license: "MIT".to_string(),
                source: Some("crates.io".to_string()),
                language: Language::Rust,
            },
            DependencyInfo {
                name: "indicatif".to_string(),
                version: "0.17.12".to_string(),
                dep_type: DependencyType::Production,
                license: "MIT".to_string(),
                source: Some("crates.io".to_string()),
                language: Language::Rust,
            },
        ];
        
        let result = checker.parse_cargo_audit_output(&audit_data, &dependencies);
        assert!(result.is_ok());
        
        let vulnerable_deps = result.unwrap();
        assert_eq!(vulnerable_deps.len(), 3); // 1 security vulnerability + 2 warnings
        
        // Check security vulnerability
        let gix_features_dep = vulnerable_deps.iter().find(|d| d.name == "gix-features").unwrap();
        assert_eq!(gix_features_dep.vulnerabilities.len(), 1);
        let vuln = &gix_features_dep.vulnerabilities[0];
        assert_eq!(vuln.vuln_type, "security");
        assert_eq!(vuln.severity, VulnerabilitySeverity::Medium); // Default for this vuln
        
        // Check unmaintained package warning
        let term_size_dep = vulnerable_deps.iter().find(|d| d.name == "term_size").unwrap();
        assert_eq!(term_size_dep.vulnerabilities.len(), 1);
        let unmaintained_vuln = &term_size_dep.vulnerabilities[0];
        assert_eq!(unmaintained_vuln.vuln_type, "unmaintained");
        assert_eq!(unmaintained_vuln.severity, VulnerabilitySeverity::Low);
        assert_eq!(unmaintained_vuln.title, "Unmaintained package: term_size");
        
        // Check yanked package warning
        let indicatif_dep = vulnerable_deps.iter().find(|d| d.name == "indicatif").unwrap();
        assert_eq!(indicatif_dep.vulnerabilities.len(), 1);
        let yanked_vuln = &indicatif_dep.vulnerabilities[0];
        assert_eq!(yanked_vuln.vuln_type, "yanked");
        assert_eq!(yanked_vuln.severity, VulnerabilitySeverity::Medium);
        assert_eq!(yanked_vuln.title, "Yanked package: indicatif");
    }
    
    #[test]
    fn test_parse_cargo_audit_vulnerabilities_only() {
        // Test with only vulnerabilities, no warnings
        let test_data = r#"{
            "vulnerabilities": {
                "found": true,
                "count": 1,
                "list": [
                    {
                        "advisory": {
                            "id": "RUSTSEC-2020-0071",
                            "package": "time",
                            "title": "Potential segfault in the time crate",
                            "description": "Unix-like systems have a limit to the number of timers that can be active at once.",
                            "date": "2020-11-11",
                            "aliases": ["CVE-2020-26235"],
                            "severity": "high"
                        },
                        "versions": {
                            "patched": [">=0.2.23"],
                            "unaffected": []
                        },
                        "package": {
                            "name": "time",
                            "version": "0.2.22"
                        }
                    }
                ]
            },
            "warnings": []
        }"#;
        
        let audit_data: Value = serde_json::from_str(test_data).expect("Failed to parse test data");
        let checker = RustVulnerabilityChecker::new();
        let dependencies = vec![
            DependencyInfo {
                name: "time".to_string(),
                version: "0.2.22".to_string(),
                dep_type: DependencyType::Production,
                license: "MIT".to_string(),
                source: Some("crates.io".to_string()),
                language: Language::Rust,
            },
        ];
        
        let result = checker.parse_cargo_audit_output(&audit_data, &dependencies);
        assert!(result.is_ok());
        
        let vulnerable_deps = result.unwrap();
        assert_eq!(vulnerable_deps.len(), 1);
        
        let time_dep = &vulnerable_deps[0];
        assert_eq!(time_dep.name, "time");
        assert_eq!(time_dep.vulnerabilities.len(), 1);
        let vuln = &time_dep.vulnerabilities[0];
        assert_eq!(vuln.vuln_type, "security");
        assert_eq!(vuln.severity, VulnerabilitySeverity::High);
        assert_eq!(vuln.id, "RUSTSEC-2020-0071");
    }
    
    #[test]
    fn test_parse_cargo_audit_warnings_only() {
        // Test with only warnings, no vulnerabilities
        let test_data = r#"{
            "vulnerabilities": {
                "found": false,
                "count": 0,
                "list": []
            },
            "warnings": {
                "unmaintained": [
                    {
                        "kind": "unmaintained",
                        "package": {
                            "name": "term_size",
                            "version": "0.3.2"
                        },
                        "advisory": {
                            "description": "The `term_size` crate is unmaintained. Use `terminal_size` instead."
                        }
                    }
                ]
            }
        }"#;
        
        let audit_data: Value = serde_json::from_str(test_data).expect("Failed to parse test data");
        let checker = RustVulnerabilityChecker::new();
        let dependencies = vec![
            DependencyInfo {
                name: "term_size".to_string(),
                version: "0.3.2".to_string(),
                dep_type: DependencyType::Production,
                license: "MIT".to_string(),
                source: Some("crates.io".to_string()),
                language: Language::Rust,
            },
        ];
        
        let result = checker.parse_cargo_audit_output(&audit_data, &dependencies);
        assert!(result.is_ok());
        
        let vulnerable_deps = result.unwrap();
        assert_eq!(vulnerable_deps.len(), 1);
        
        let term_size_dep = &vulnerable_deps[0];
        assert_eq!(term_size_dep.name, "term_size");
        assert_eq!(term_size_dep.vulnerabilities.len(), 1);
        let vuln = &term_size_dep.vulnerabilities[0];
        assert_eq!(vuln.vuln_type, "unmaintained");
        assert_eq!(vuln.severity, VulnerabilitySeverity::Low);
        assert_eq!(vuln.title, "Unmaintained package: term_size");
    }
}